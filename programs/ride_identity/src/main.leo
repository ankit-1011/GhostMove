// GhostMove: Temporary Zero-Knowledge Identity Tokens
// Each ride creates a non-transferable ZK identity that auto-expires after completion

program ride_identity_v2.aleo {
    // Temporary identity token record (private state)
    // This identity exists only for the duration of a single ride
    record RideIdentity {
        owner: address,        // Required: owner field
        rider_address: address,
        driver_address: address,
        ride_id: field,
        created_at: u64,
        expires_at: u64,
        is_active: bool,
        // Note: _nonce and _version are auto-generated by compiler
    }

    // Constructor (required for deployment)
    @noupgrade
    async constructor() {}

    // Mint a new temporary identity for a ride
    // This identity is bound to both rider and driver without revealing real identities
    transition mint_identity(
        public rider_address: address,
        public driver_address: address,
        public ride_id: field,
        public duration_seconds: u64,
        public timestamp: u64
    ) -> RideIdentity {
        // Ensure rider and driver are different
        assert(rider_address != driver_address);

        // Calculate expiration time
        let expires_at: u64 = timestamp + duration_seconds;

        // Create the temporary identity
        let identity: RideIdentity = RideIdentity {
            owner: rider_address,  // Required owner field
            rider_address,
            driver_address,
            ride_id,
            created_at: timestamp,
            expires_at,
            is_active: true,
        };

        return identity;
    }

    // Verify identity is valid and not expired
    // Used for authentication during the ride
    transition verify_identity(
        private identity: RideIdentity,
        public caller_address: address,
        public current_timestamp: u64
    ) -> bool {
        // Verify caller is either rider or driver
        assert(caller_address == identity.rider_address || caller_address == identity.driver_address);

        // Check if identity is still active
        assert(identity.is_active);

        // Check if identity has not expired
        assert(current_timestamp <= identity.expires_at);

        // Verify record ownership
        assert_eq(identity.owner, caller_address);

        return true;
    }

    // Complete ride and burn the temporary identity
    // This ensures no permanent identity record exists
    transition complete_ride(
        private identity: RideIdentity,
        public caller_address: address,
        public current_timestamp: u64
    ) -> RideIdentity {
        // Verify caller is authorized (rider or driver)
        assert(caller_address == identity.rider_address || caller_address == identity.driver_address);

        // Verify identity is still active
        assert(identity.is_active);

        // Verify record ownership
        assert_eq(identity.owner, caller_address);

        // Mark identity as inactive (burn it)
        let burned_identity: RideIdentity = RideIdentity {
            owner: identity.owner,
            rider_address: identity.rider_address,
            driver_address: identity.driver_address,
            ride_id: identity.ride_id,
            created_at: identity.created_at,
            expires_at: identity.expires_at,
            is_active: false,
        };

        return burned_identity;
    }

    // Check if identity has expired
    transition is_expired(
        private identity: RideIdentity,
        public current_timestamp: u64
    ) -> bool {
        return current_timestamp > identity.expires_at;
    }
}