// GhostMove: Zero-Knowledge Proximity Matching
// Drivers prove proximity to pickup location without revealing exact coordinates

program proximity_matching_v2.aleo {
    // Location coordinates (encrypted)
    // These are private fields that won't be revealed in proofs
    struct Location {
        latitude: field,   // Encrypted latitude
        longitude: field, // Encrypted longitude
    }

    // Proximity proof result record (private state)
    record ProximityProof {
        owner: address,        // Required: owner field
        ride_id: field,
        driver_address: address,
        is_within_range: bool,
        max_distance_km: u32,
        proof_timestamp: u64,
        // Note: _nonce and _version are auto-generated by compiler
    }

    // Ride request record with encrypted pickup location
    record RideRequest {
        owner: address,        // Required: owner field (rider)
        ride_id: field,
        rider_address: address,
        pickup_location: Location,
        max_distance_km: u32,  // Maximum acceptable distance in km
        created_at: u64,
        is_active: bool,
        // Note: _nonce and _version are auto-generated by compiler
    }

    // Constructor (required for deployment)
    @noupgrade
    async constructor() {}

    // Create a ride request with encrypted pickup location
    transition create_ride_request(
        public ride_id: field,
        public rider_address: address,
        private pickup_latitude: field,
        private pickup_longitude: field,
        public max_distance_km: u32,
        public timestamp: u64
    ) -> RideRequest {
        // Create encrypted location
        let pickup_location: Location = Location {
            latitude: pickup_latitude,
            longitude: pickup_longitude,
        };

        // Create ride request
        let ride_request: RideRequest = RideRequest {
            owner: rider_address,  // Required owner field
            ride_id,
            rider_address,
            pickup_location,
            max_distance_km,
            created_at: timestamp,
            is_active: true,
        };

        return ride_request;
    }

    // Driver proves proximity without revealing exact location
    // Uses zero-knowledge range proofs to verify distance
    transition prove_proximity(
        private ride_request: RideRequest,
        public driver_address: address,
        private driver_latitude: field,   // Private: driver's actual location
        private driver_longitude: field, // Private: driver's actual location
        public timestamp: u64
    ) -> ProximityProof {
        // Verify ride is still active
        assert(ride_request.is_active);

        // Calculate squared distance (ZK-friendly, avoids sqrt)
        // This computation happens without revealing actual coordinates
        let distance_squared: field = calculate_distance(
            ride_request.pickup_location.latitude,
            ride_request.pickup_location.longitude,
            driver_latitude,
            driver_longitude
        );

        // Convert max_distance to squared for comparison
        let max_distance_field: field = ride_request.max_distance_km as field;
        let max_distance_squared: field = max_distance_field * max_distance_field;

        // Verify squared distance is within acceptable range (ZK range proof)
        // This proves "distance <= max_distance" without revealing the actual distance
        let is_within_range: bool = distance_squared <= max_distance_squared;

        // Only proceed if within range
        assert(is_within_range);

        // Create proximity proof (only reveals boolean result, not actual distance or locations)
        let proof: ProximityProof = ProximityProof {
            owner: driver_address,  // Required owner field
            ride_id: ride_request.ride_id,
            driver_address,
            is_within_range,
            max_distance_km: ride_request.max_distance_km,
            proof_timestamp: timestamp,
        };

        return proof;
    }

    // Calculate squared distance between two points (ZK-friendly)
    // Uses simplified distance calculation to avoid sqrt in ZK
    function calculate_distance(
        lat1: field,
        lon1: field,
        lat2: field,
        lon2: field
    ) -> field {
        // For ZK-friendly computation, we use squared Euclidean distance
        // This avoids sqrt which is expensive in zero-knowledge
        
        // Calculate differences
        let delta_lat: field = lat2 - lat1;
        let delta_lon: field = lon2 - lon1;
        
        // Calculate squared distance (approximation for small distances)
        // For distances < 100km, lat/lon can be treated as linear
        // Using integer approximation: 1 degree â‰ˆ 111 km
        let lat_km_scaled: field = delta_lat * 111field;
        let lon_km_scaled: field = delta_lon * 111field;
        
        // Squared distance (scaled)
        let distance_squared: field = lat_km_scaled * lat_km_scaled + lon_km_scaled * lon_km_scaled;
        
        return distance_squared;
    }

    // Verify a proximity proof (public verification)
    transition verify_proximity_proof(
        private proof: ProximityProof,
        public caller_address: address
    ) -> bool {
        // Verify caller owns the proof or is the driver
        assert(caller_address == proof.owner || caller_address == proof.driver_address);

        // Verify proof is valid
        assert(proof.is_within_range);

        return true;
    }

    // Cancel ride request
    transition cancel_ride_request(
        private ride_request: RideRequest,
        public caller_address: address
    ) -> RideRequest {
        // Verify caller is the rider
        assert(caller_address == ride_request.rider_address);
        assert(caller_address == ride_request.owner);

        // Mark as inactive
        let cancelled_request: RideRequest = RideRequest {
            owner: ride_request.owner,
            ride_id: ride_request.ride_id,
            rider_address: ride_request.rider_address,
            pickup_location: ride_request.pickup_location,
            max_distance_km: ride_request.max_distance_km,
            created_at: ride_request.created_at,
            is_active: false,
        };

        return cancelled_request;
    }

    // Check if ride request is active
    transition is_ride_active(
        private ride_request: RideRequest
    ) -> bool {
        return ride_request.is_active;
    }
}